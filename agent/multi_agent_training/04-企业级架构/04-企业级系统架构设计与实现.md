# ç¬¬å››å¤©ï¼šä¼ä¸šçº§ç³»ç»Ÿæ¶æ„è®¾è®¡ä¸å®ç°

## å­¦ä¹ ç›®æ ‡

- æŒæ¡ä¼ä¸šçº§å¤šæ™ºèƒ½ä½“ç³»ç»Ÿæ¶æ„è®¾è®¡åŸåˆ™
- å­¦ä¼šè®¾è®¡å’Œå®ç°æ ¸å¿ƒç³»ç»Ÿç»„ä»¶
- æŒæ¡å®‰å…¨ã€ç›‘æ§å’Œè¿ç»´æœ€ä½³å®è·µ
- å­¦ä¼šç³»ç»Ÿæ€§èƒ½ä¼˜åŒ–å’Œæ•…éšœå¤„ç†
- äº†è§£å®é™…é¡¹ç›®ä¸­çš„æ¶æ„å®ç°å’Œæœ€ä½³å®è·µ

## å‚è€ƒé¡¹ç›®

æœ¬è¯¾ç¨‹æ·±å…¥è®²è§£ä¼ä¸šçº§å¤šæ™ºèƒ½ä½“ç³»ç»Ÿçš„æ¶æ„è®¾è®¡åŸåˆ™ã€æ ¸å¿ƒç»„ä»¶å®ç°å’Œæœ€ä½³å®è·µï¼Œå¸®åŠ©å­¦å‘˜æ„å»ºå¯æ‰©å±•ã€é«˜å¯ç”¨çš„ç”Ÿäº§çº§ç³»ç»Ÿã€‚

**ğŸ’¡ å®é™…ä»£ç å‚è€ƒ**ï¼šå®Œæ•´çš„ä¼ä¸šçº§æ¶æ„å®ç°å¯å‚è€ƒé¡¹ç›®ä¸­çš„ä»¥ä¸‹æ–‡ä»¶ï¼š

- `multi_agent_system/main.py` - å¤šæ™ºèƒ½ä½“ç³»ç»Ÿä¸»å…¥å£å’Œæ•´ä½“æ¶æ„
- `multi_agent_system/src/agents/base_agent.py` - BDIæ™ºèƒ½ä½“åŸºç¡€æ¶æ„
- `multi_agent_system/src/communication/message_bus.py` - ä¼ä¸šçº§æ¶ˆæ¯æ€»çº¿
- `multi_agent_system/src/workflows/langgraph_workflow.py` - å·¥ä½œæµå¼•æ“æ¶æ„
- `multi_agent_system/src/monitoring/langsmith_integration.py` - ç›‘æ§ç³»ç»Ÿé›†æˆ
- `customer_service_system.py` - ä¼ä¸šçº§å®¢æœç³»ç»Ÿå®ç°
- `multi_agent_system/src/security/` - å®‰å…¨ç»„ä»¶å®ç°
- `multi_agent_system/src/infrastructure/` - åŸºç¡€è®¾æ–½ç»„ä»¶

**ä»£ç å¼•ç”¨**: å®Œæ•´çš„ä¼ä¸šçº§æ¶æ„å®ç°è¯·å‚è€ƒ `multi_agent_system/main.py`

ä¼ä¸šçº§æ¶æ„çš„æ ¸å¿ƒç‰¹æ€§ï¼š

**æ ¸å¿ƒç»„ä»¶**ï¼š

- `ArchitectureLayer`: æ¶æ„å±‚æ¬¡ç®¡ç†ï¼ˆè¡¨ç¤ºå±‚ã€ä¸šåŠ¡å±‚ã€æœåŠ¡å±‚ã€æ•°æ®å±‚ã€åŸºç¡€è®¾æ–½å±‚ï¼‰
- `EnterpriseComponent`: ä¼ä¸šçº§ç»„ä»¶å®šä¹‰ï¼ˆä¾èµ–å…³ç³»ã€å¯æ‰©å±•æ€§ã€å¯ç”¨æ€§ã€å®‰å…¨çº§åˆ«ï¼‰
- `EnterpriseArchitectureManager`: æ¶æ„ç®¡ç†å™¨ï¼Œæ”¯æŒç»„ä»¶æ³¨å†Œå’Œç³»ç»Ÿå¯åŠ¨
- `MultiAgentSystem`: å¤šæ™ºèƒ½ä½“ç³»ç»Ÿä¸»ç±»ï¼Œå®ç°ä¼ä¸šçº§æ¶æ„

**ä¼ä¸šçº§ç‰¹æ€§**ï¼š

- åˆ†å±‚æ¶æ„è®¾è®¡ï¼Œæ¸…æ™°çš„èŒè´£åˆ†ç¦»
- ç»„ä»¶åŒ–ç®¡ç†ï¼Œæ”¯æŒåŠ¨æ€æ³¨å†Œå’Œç›‘æ§
- å¼‚æ­¥å¯åŠ¨æœºåˆ¶ï¼ŒæŒ‰ä¾èµ–é¡ºåºå¯åŠ¨ç»„ä»¶
- é›†æˆç›‘æ§å’Œå®‰å…¨ç­–ç•¥

**ğŸ’¡ å®é™…ä»£ç å‚è€ƒ**ï¼šå®Œæ•´çš„ä¼ä¸šçº§æ¶æ„å®ç°å¯å‚è€ƒé¡¹ç›®ä¸­çš„ä»¥ä¸‹æ–‡ä»¶ï¼š

- `main.py` - å¤šæ™ºèƒ½ä½“ç³»ç»Ÿä¸»å…¥å£å’Œæ•´ä½“æ¶æ„
- `customer_service_system.py` - ä¼ä¸šçº§å®¢æœç³»ç»Ÿå®ç°
- `message_bus.py` - æ¶ˆæ¯æ€»çº¿å’Œé€šä¿¡ä¸­é—´ä»¶
- `langgraph_workflow.py` - å·¥ä½œæµå¼•æ“å®ç°
- `langsmith_integration.py` - ç›‘æ§ç³»ç»Ÿé›†æˆ

**æ¶æ„ç‰¹è‰²**ï¼šæœ¬é¡¹ç›®é‡‡ç”¨ç°ä»£å¾®æœåŠ¡æ¶æ„ï¼Œé›†æˆäº†BDIæ™ºèƒ½ä½“æ¨¡å‹ã€LangGraphå·¥ä½œæµå¼•æ“ã€LangSmithç›‘æ§å¹³å°ï¼Œæä¾›äº†å®Œæ•´çš„ä¼ä¸šçº§å¤šæ™ºèƒ½ä½“è§£å†³æ–¹æ¡ˆã€‚

---

## 1. ä¼ä¸šçº§æ¶æ„è®¾è®¡åŸåˆ™

### 1.1 è®¾è®¡åŸåˆ™æ¦‚è¿°

#### 1.1.1 æ ¸å¿ƒè®¾è®¡åŸåˆ™

```python
**ä»£ç å¼•ç”¨**: å®Œæ•´çš„ä¼ä¸šçº§æ¶æ„è®¾è®¡åŸåˆ™å®ç°è¯·å‚è€ƒ `multi_agent_system/main.py` ä¸­çš„ `EnterpriseArchitecturalPrinciples` å’Œ `MultiAgentSystem` ç±»

ä¼ä¸šçº§æ¶æ„è®¾è®¡åŸåˆ™çš„æ ¸å¿ƒç‰¹æ€§ï¼š

**è®¾è®¡åŸåˆ™**ï¼š
- `EnterpriseArchitecturalPrinciples`: å®šä¹‰äº†8å¤§æ ¸å¿ƒåŸåˆ™ï¼ˆå¯æ‰©å±•æ€§ã€å¯é æ€§ã€å®‰å…¨æ€§ã€å¯ç»´æŠ¤æ€§ã€æ€§èƒ½ã€å¯è§‚æµ‹æ€§ã€çµæ´»æ€§ã€æˆæœ¬æ•ˆç‡ï¼‰
- `MultiAgentSystem`: ä¸»ç³»ç»Ÿç±»ï¼Œå®ç°ä¼ä¸šçº§æ¶æ„çš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸç®¡ç†

**ç³»ç»Ÿåˆå§‹åŒ–æµç¨‹**ï¼š
1. åŸºç¡€æ™ºèƒ½ä½“æ¶æ„åˆå§‹åŒ–ï¼ˆBDIæ¨¡å‹ï¼‰
2. ä¸“ä¸šåŒ–æ™ºèƒ½ä½“åˆå§‹åŒ–ï¼ˆä¸šåŠ¡ç‰¹å®šæ™ºèƒ½ä½“ï¼‰
3. é€šä¿¡ä¸­é—´ä»¶åˆå§‹åŒ–ï¼ˆæ¶ˆæ¯æ€»çº¿ï¼‰
4. å·¥ä½œæµå¼•æ“åˆå§‹åŒ–ï¼ˆLangGraphï¼‰
5. ç›‘æ§ç³»ç»Ÿåˆå§‹åŒ–ï¼ˆLangSmithï¼‰
6. ç¤ºä¾‹åº”ç”¨åˆå§‹åŒ–ï¼ˆå®¢æœç³»ç»Ÿï¼‰

**ä¼ä¸šçº§ç‰¹æ€§**ï¼š
- æ¨¡å—åŒ–è®¾è®¡ï¼Œæ¯ä¸ªç»„ä»¶ç‹¬ç«‹å¯æ›¿æ¢
- å¼‚æ­¥æ¶æ„ï¼Œæ”¯æŒé«˜å¹¶å‘å¤„ç†
- å…¨é“¾è·¯ç›‘æ§ï¼Œé›†æˆLangSmith
- å®¹é”™è®¾è®¡ï¼Œè‡ªåŠ¨æ•…éšœæ¢å¤
```

### 1.2 å®é™…é¡¹ç›®æ¶æ„åˆ†æ

#### 1.2.1 é¡¹ç›®æ¶æ„å±‚æ¬¡

```python
# åŸºäºå®é™…é¡¹ç›®çš„æ¶æ„å±‚æ¬¡åˆ†æ
class ProjectArchitectureLayers:
    """é¡¹ç›®æ¶æ„å±‚æ¬¡"""
    
    def __init__(self):
        self.presentation_layer = {
            "description": "è¡¨ç¤ºå±‚ - ç”¨æˆ·æ¥å£å’ŒAPI",
            "components": [
                "main.py - ç³»ç»Ÿä¸»å…¥å£",
                "APIæ¥å£ - RESTful APIè®¾è®¡",
                "ç®¡ç†ç•Œé¢ - ç³»ç»Ÿç›‘æ§é¢æ¿"
            ],
            "technologies": ["FastAPI", "WebSocket", "HTTP/HTTPS"]
        }
        
        self.business_layer = {
            "description": "ä¸šåŠ¡å±‚ - æ™ºèƒ½ä½“ç¼–æ’å’Œä¸šåŠ¡é€»è¾‘",
            "components": [
                "customer_service_system.py - å®¢æœä¸šåŠ¡é€»è¾‘",
                "langgraph_workflow.py - å·¥ä½œæµç¼–æ’",
                "ä¸šåŠ¡è§„åˆ™å¼•æ“ - åŠ¨æ€è§„åˆ™é…ç½®"
            ],
            "technologies": ["LangGraph", "ä¸šåŠ¡è§„åˆ™å¼•æ“", "å·¥ä½œæµå¼•æ“"]
        }
        
        self.service_layer = {
            "description": "æœåŠ¡å±‚ - å¾®æœåŠ¡å’Œä¸­é—´ä»¶",
            "components": [
                "base_agent.py - BDIæ™ºèƒ½ä½“æœåŠ¡",
                "message_bus.py - æ¶ˆæ¯é€šä¿¡æœåŠ¡",
                "langsmith_integration.py - ç›‘æ§æœåŠ¡"
            ],
            "technologies": ["å¼‚æ­¥æ¶ˆæ¯é˜Ÿåˆ—", "æœåŠ¡å‘ç°", "è´Ÿè½½å‡è¡¡"]
        }
        
        self.data_layer = {
            "description": "æ•°æ®å±‚ - æ•°æ®å­˜å‚¨å’Œç®¡ç†",
            "components": [
                "æ™ºèƒ½ä½“çŠ¶æ€å­˜å‚¨",
                "æ¶ˆæ¯å†å²å­˜å‚¨",
                "ç›‘æ§æ•°æ®å­˜å‚¨",
                "é…ç½®æ•°æ®å­˜å‚¨"
            ],
            "technologies": ["Redis", "PostgreSQL", "æ–‡ä»¶å­˜å‚¨", "æ—¶åºæ•°æ®åº“"]
        }

# æ¶æ„ç‰¹æ€§å¯¹æ¯”
class ArchitectureFeatures:
    """æ¶æ„ç‰¹æ€§å¯¹æ¯”"""
    
    @staticmethod
    def get_feature_comparison():
        return {
            "ä¼ ç»Ÿå•ä½“æ¶æ„": {
                "ä¼˜ç‚¹": ["ç®€å•éƒ¨ç½²", "å¼€å‘å¿«é€Ÿ", "è°ƒè¯•å®¹æ˜“"],
                "ç¼ºç‚¹": ["æ‰©å±•å›°éš¾", "æŠ€æœ¯æ ˆå›ºå®š", "æ•…éšœå½±å“å…¨å±€"],
                "é€‚ç”¨åœºæ™¯": "å°å‹é¡¹ç›®ã€åŸå‹å¼€å‘"
            },
            "å¾®æœåŠ¡æ¶æ„": {
                "ä¼˜ç‚¹": ["ç‹¬ç«‹æ‰©å±•", "æŠ€æœ¯å¤šæ ·æ€§", "æ•…éšœéš”ç¦»"],
                "ç¼ºç‚¹": ["å¤æ‚åº¦é«˜", "ç½‘ç»œå¼€é”€", "æ•°æ®ä¸€è‡´æ€§"],
                "é€‚ç”¨åœºæ™¯": "å¤§å‹ä¼ä¸šåº”ç”¨ã€é«˜å¹¶å‘ç³»ç»Ÿ"
            },
            "æ™ºèƒ½ä½“æ¶æ„": {
                "ä¼˜ç‚¹": ["è‡ªä¸»å†³ç­–", "åŠ¨æ€åä½œ", "æ™ºèƒ½é€‚åº”"],
                "ç¼ºç‚¹": ["è¡Œä¸ºä¸å¯é¢„æµ‹", "è°ƒè¯•å›°éš¾", "æ€§èƒ½å¼€é”€"],
                "é€‚ç”¨åœºæ™¯": "å¤æ‚ä¸šåŠ¡åœºæ™¯ã€æ™ºèƒ½åŒ–åº”ç”¨"
            },
            "æœ¬é¡¹ç›®æ¶æ„": {
                "ä¼˜ç‚¹": ["ç»“åˆä¸‰è€…ä¼˜åŠ¿", "ä¼ä¸šçº§ç‰¹æ€§", "å®Œæ•´ç”Ÿæ€"],
                "ç¼ºç‚¹": ["å­¦ä¹ æˆæœ¬é«˜", "åˆæœŸå¤æ‚"],
                "é€‚ç”¨åœºæ™¯": "ä¼ä¸šçº§AIåº”ç”¨ã€æ™ºèƒ½åŒ–ä¸šåŠ¡ç³»ç»Ÿ"
            }
        }
```

### 1.2 åˆ†å±‚æ¶æ„æ¨¡å¼

#### 1.2.1 å››å±‚æ¶æ„è®¾è®¡

```python
class EnterpriseArchitecture:
    """ä¼ä¸šçº§å››å±‚æ¶æ„"""
    
    def __init__(self):
        self.presentation_layer = PresentationLayer()
        self.business_layer = BusinessLayer()
        self.service_layer = ServiceLayer()
        self.data_layer = DataLayer()
    
    class PresentationLayer:
        """è¡¨ç¤ºå±‚ - APIç½‘å…³ã€Webç•Œé¢"""
        def __init__(self):
            self.api_gateway = "APIç½‘å…³"
            self.web_interface = "Webç®¡ç†ç•Œé¢"
            self.mobile_app = "ç§»åŠ¨ç«¯åº”ç”¨"
    
    class BusinessLayer:
        """ä¸šåŠ¡å±‚ - æ™ºèƒ½ä½“ç¼–æ’ã€ä¸šåŠ¡é€»è¾‘"""
        def __init__(self):
            self.agent_orchestrator = "æ™ºèƒ½ä½“ç¼–æ’å™¨"
            self.workflow_engine = "å·¥ä½œæµå¼•æ“"
            self.business_rules = "ä¸šåŠ¡è§„åˆ™å¼•æ“"
    
    class ServiceLayer:
        """æœåŠ¡å±‚ - å¾®æœåŠ¡ã€ä¸­é—´ä»¶"""
        def __init__(self):
            self.agent_services = "æ™ºèƒ½ä½“æœåŠ¡é›†ç¾¤"
            self.message_queue = "æ¶ˆæ¯é˜Ÿåˆ—"
            self.cache_service = "ç¼“å­˜æœåŠ¡"
            self.auth_service = "è®¤è¯æˆæƒæœåŠ¡"
    
    class DataLayer:
        """æ•°æ®å±‚ - æ•°æ®åº“ã€å­˜å‚¨"""
        def __init__(self):
            self.primary_database = "ä¸»æ•°æ®åº“"
            self.cache_database = "ç¼“å­˜æ•°æ®åº“"
            self.file_storage = "æ–‡ä»¶å­˜å‚¨"
            self.log_storage = "æ—¥å¿—å­˜å‚¨"
```

### 1.3 å¾®æœåŠ¡æ¶æ„æ¨¡å¼

#### 1.3.1 æ™ºèƒ½ä½“å¾®æœåŠ¡è®¾è®¡

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import asyncio
from typing import Dict, Any

class AgentMicroservice:
    """æ™ºèƒ½ä½“å¾®æœåŠ¡åŸºç±»"""
    
    def __init__(self, service_name: str, port: int):
        self.service_name = service_name
        self.port = port
        self.app = FastAPI(title=f"{service_name} Service")
        self.health_status = "healthy"
        self._setup_routes()
    
    def _setup_routes(self):
        """è®¾ç½®è·¯ç”±"""
        @self.app.get("/health")
        async def health_check():
            return {"status": self.health_status, "service": self.service_name}
        
        @self.app.post("/process")
        async def process_request(request: ProcessRequest):
            try:
                result = await self.process_task(request.task, request.context)
                return {"success": True, "result": result}
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
    
    @abstractmethod
    async def process_task(self, task: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """å¤„ç†ä»»åŠ¡çš„æŠ½è±¡æ–¹æ³•"""
        pass

class ProcessRequest(BaseModel):
    task: Dict[str, Any]
    context: Dict[str, Any] = {}

# å…·ä½“æ™ºèƒ½ä½“æœåŠ¡å®ç°
class AnalyzerService(AgentMicroservice):
    """åˆ†æå™¨æœåŠ¡"""
    
    def __init__(self):
        super().__init__("analyzer", 8001)
    
    async def process_task(self, task: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """æ‰§è¡Œæ•°æ®åˆ†æä»»åŠ¡"""
        # æ¨¡æ‹Ÿåˆ†æé€»è¾‘
        await asyncio.sleep(0.1)  # æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
        
        return {
            "analysis_type": task.get("type", "general"),
            "insights": ["insight1", "insight2", "insight3"],
            "confidence": 0.95,
            "processing_time": 0.1
        }

class ExecutorService(AgentMicroservice):
    """æ‰§è¡Œå™¨æœåŠ¡"""
    
    def __init__(self):
        super().__init__("executor", 8002)
    
    async def process_task(self, task: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """æ‰§è¡Œå…·ä½“ä»»åŠ¡"""
        # æ¨¡æ‹Ÿæ‰§è¡Œé€»è¾‘
        await asyncio.sleep(0.2)
        
        return {
            "execution_status": "completed",
            "actions_taken": task.get("actions", []),
            "results": {"status": "success", "output": "Task completed successfully"}
        }
```

---

## 2. æ ¸å¿ƒç»„ä»¶æ¶æ„

### 2.1 æ™ºèƒ½ä½“ç®¡ç†å™¨

#### 2.1.1 æ™ºèƒ½ä½“ç”Ÿå‘½å‘¨æœŸç®¡ç†

```python
import asyncio
import uuid
from enum import Enum
from typing import Dict, List, Optional, Callable
from datetime import datetime

class AgentStatus(Enum):
    INITIALIZING = "initializing"
    READY = "ready"
    BUSY = "busy"
    ERROR = "error"
    SHUTDOWN = "shutdown"

class AgentInfo:
    def __init__(self, agent_id: str, agent_type: str, capabilities: List[str]):
        self.agent_id = agent_id
        self.agent_type = agent_type
        self.capabilities = capabilities
        self.status = AgentStatus.INITIALIZING
        self.created_at = datetime.utcnow()
        self.last_activity = datetime.utcnow()
        self.task_count = 0
        self.error_count = 0

class AgentManager:
    """æ™ºèƒ½ä½“ç®¡ç†å™¨"""
    
    def __init__(self):
        self.agents: Dict[str, AgentInfo] = {}
        self.agent_instances: Dict[str, Any] = {}
        self.load_balancer = LoadBalancer()
        self.health_monitor = HealthMonitor()
    
    async def register_agent(self, agent_type: str, capabilities: List[str], 
                           agent_factory: Callable) -> str:
        """æ³¨å†Œæ™ºèƒ½ä½“"""
        agent_id = str(uuid.uuid4())
        
        # åˆ›å»ºæ™ºèƒ½ä½“ä¿¡æ¯
        agent_info = AgentInfo(agent_id, agent_type, capabilities)
        self.agents[agent_id] = agent_info
        
        try:
            # åˆ›å»ºæ™ºèƒ½ä½“å®ä¾‹
            agent_instance = await agent_factory()
            self.agent_instances[agent_id] = agent_instance
            
            # æ›´æ–°çŠ¶æ€
            agent_info.status = AgentStatus.READY
            
            # å¯åŠ¨å¥åº·ç›‘æ§
            asyncio.create_task(self.health_monitor.monitor_agent(agent_id))
            
            return agent_id
            
        except Exception as e:
            agent_info.status = AgentStatus.ERROR
            raise Exception(f"æ™ºèƒ½ä½“æ³¨å†Œå¤±è´¥: {e}")
    
    async def assign_task(self, task: Dict[str, Any], 
                         required_capabilities: List[str]) -> Optional[str]:
        """åˆ†é…ä»»åŠ¡ç»™åˆé€‚çš„æ™ºèƒ½ä½“"""
        # æŸ¥æ‰¾å…·å¤‡æ‰€éœ€èƒ½åŠ›çš„æ™ºèƒ½ä½“
        suitable_agents = []
        for agent_id, agent_info in self.agents.items():
            if (agent_info.status == AgentStatus.READY and 
                all(cap in agent_info.capabilities for cap in required_capabilities)):
                suitable_agents.append(agent_id)
        
        if not suitable_agents:
            return None
        
        # ä½¿ç”¨è´Ÿè½½å‡è¡¡å™¨é€‰æ‹©æœ€ä¼˜æ™ºèƒ½ä½“
        selected_agent_id = self.load_balancer.select_agent(suitable_agents)
        
        # æ›´æ–°æ™ºèƒ½ä½“çŠ¶æ€
        agent_info = self.agents[selected_agent_id]
        agent_info.status = AgentStatus.BUSY
        agent_info.task_count += 1
        agent_info.last_activity = datetime.utcnow()
        
        return selected_agent_id
    
    async def complete_task(self, agent_id: str, success: bool = True):
        """ä»»åŠ¡å®Œæˆå›è°ƒ"""
        if agent_id in self.agents:
            agent_info = self.agents[agent_id]
            agent_info.status = AgentStatus.READY
            agent_info.last_activity = datetime.utcnow()
            
            if not success:
                agent_info.error_count += 1
    
    def get_agent_statistics(self) -> Dict[str, Any]:
        """è·å–æ™ºèƒ½ä½“ç»Ÿè®¡ä¿¡æ¯"""
        total_agents = len(self.agents)
        status_counts = {}
        
        for agent_info in self.agents.values():
            status = agent_info.status.value
            status_counts[status] = status_counts.get(status, 0) + 1
        
        return {
            "total_agents": total_agents,
            "status_distribution": status_counts,
            "total_tasks_processed": sum(agent.task_count for agent in self.agents.values()),
            "total_errors": sum(agent.error_count for agent in self.agents.values())
        }

class LoadBalancer:
    """è´Ÿè½½å‡è¡¡å™¨"""
    
    def __init__(self):
        self.agent_loads: Dict[str, float] = {}
    
    def select_agent(self, agent_ids: List[str]) -> str:
        """é€‰æ‹©è´Ÿè½½æœ€ä½çš„æ™ºèƒ½ä½“"""
        if not agent_ids:
            raise ValueError("æ²¡æœ‰å¯ç”¨çš„æ™ºèƒ½ä½“")
        
        # ç®€å•çš„è½®è¯¢ç­–ç•¥
        min_load = float('inf')
        selected_agent = agent_ids[0]
        
        for agent_id in agent_ids:
            load = self.agent_loads.get(agent_id, 0)
            if load < min_load:
                min_load = load
                selected_agent = agent_id
        
        # å¢åŠ è´Ÿè½½
        self.agent_loads[selected_agent] = self.agent_loads.get(selected_agent, 0) + 1
        
        return selected_agent
    
    def update_agent_load(self, agent_id: str, load_delta: float):
        """æ›´æ–°æ™ºèƒ½ä½“è´Ÿè½½"""
        current_load = self.agent_loads.get(agent_id, 0)
        self.agent_loads[agent_id] = max(0, current_load + load_delta)

class HealthMonitor:
    """å¥åº·ç›‘æ§å™¨"""
    
    async def monitor_agent(self, agent_id: str):
        """ç›‘æ§æ™ºèƒ½ä½“å¥åº·çŠ¶æ€"""
        while True:
            try:
                # æ‰§è¡Œå¥åº·æ£€æŸ¥
                is_healthy = await self._check_agent_health(agent_id)
                
                if not is_healthy:
                    await self._handle_unhealthy_agent(agent_id)
                
                await asyncio.sleep(30)  # 30ç§’æ£€æŸ¥ä¸€æ¬¡
                
            except Exception as e:
                print(f"å¥åº·ç›‘æ§é”™è¯¯ {agent_id}: {e}")
                await asyncio.sleep(60)  # é”™è¯¯æ—¶å»¶é•¿æ£€æŸ¥é—´éš”
    
    async def _check_agent_health(self, agent_id: str) -> bool:
        """æ£€æŸ¥æ™ºèƒ½ä½“å¥åº·çŠ¶æ€"""
        # å®ç°å…·ä½“çš„å¥åº·æ£€æŸ¥é€»è¾‘
        # ä¾‹å¦‚ï¼šæ£€æŸ¥å“åº”æ—¶é—´ã€å†…å­˜ä½¿ç”¨ã€é”™è¯¯ç‡ç­‰
        return True  # ç®€åŒ–å®ç°
    
    async def _handle_unhealthy_agent(self, agent_id: str):
        """å¤„ç†ä¸å¥åº·çš„æ™ºèƒ½ä½“"""
        print(f"æ£€æµ‹åˆ°ä¸å¥åº·çš„æ™ºèƒ½ä½“: {agent_id}")
        # å®ç°æ¢å¤ç­–ç•¥ï¼šé‡å¯ã€æ›¿æ¢ç­‰
```

### 2.2 é€šä¿¡æ€»çº¿

#### 2.2.1 ä¼ä¸šçº§æ¶ˆæ¯æ€»çº¿

```python
import asyncio
import json
from typing import Dict, List, Callable, Any
from dataclasses import dataclass, asdict
from datetime import datetime
import aioredis

@dataclass
class Message:
    id: str
    sender: str
    receiver: str
    message_type: str
    payload: Dict[str, Any]
    timestamp: datetime
    priority: int = 1
    ttl: int = 3600  # æ¶ˆæ¯å­˜æ´»æ—¶é—´ï¼ˆç§’ï¼‰

class MessageBus:
    """ä¼ä¸šçº§æ¶ˆæ¯æ€»çº¿"""
    
    def __init__(self, redis_url: str = "redis://localhost:6379"):
        self.redis_url = redis_url
        self.redis = None
        self.subscribers: Dict[str, List[Callable]] = {}
        self.message_handlers: Dict[str, Callable] = {}
        self.is_running = False
    
    async def initialize(self):
        """åˆå§‹åŒ–æ¶ˆæ¯æ€»çº¿"""
        self.redis = await aioredis.from_url(self.redis_url)
        self.is_running = True
        
        # å¯åŠ¨æ¶ˆæ¯å¤„ç†å¾ªç¯
        asyncio.create_task(self._message_processing_loop())
    
    async def publish(self, message: Message) -> bool:
        """å‘å¸ƒæ¶ˆæ¯"""
        try:
            # åºåˆ—åŒ–æ¶ˆæ¯
            message_data = {
                **asdict(message),
                'timestamp': message.timestamp.isoformat()
            }
            
            # å‘å¸ƒåˆ°Redis
            await self.redis.lpush(
                f"queue:{message.receiver}",
                json.dumps(message_data)
            )
            
            # è®¾ç½®TTL
            await self.redis.expire(f"queue:{message.receiver}", message.ttl)
            
            # å‘å¸ƒé€šçŸ¥
            await self.redis.publish(
                f"notify:{message.receiver}",
                message.id
            )
            
            return True
            
        except Exception as e:
            print(f"æ¶ˆæ¯å‘å¸ƒå¤±è´¥: {e}")
            return False
    
    async def subscribe(self, agent_id: str, handler: Callable[[Message], None]):
        """è®¢é˜…æ¶ˆæ¯"""
        if agent_id not in self.subscribers:
            self.subscribers[agent_id] = []
        
        self.subscribers[agent_id].append(handler)
        
        # å¯åŠ¨è®¢é˜…ç›‘å¬
        asyncio.create_task(self._subscribe_to_notifications(agent_id))
    
    async def _subscribe_to_notifications(self, agent_id: str):
        """ç›‘å¬æ¶ˆæ¯é€šçŸ¥"""
        pubsub = self.redis.pubsub()
        await pubsub.subscribe(f"notify:{agent_id}")
        
        async for message in pubsub.listen():
            if message['type'] == 'message':
                # å¤„ç†æ–°æ¶ˆæ¯é€šçŸ¥
                await self._process_agent_messages(agent_id)
    
    async def _process_agent_messages(self, agent_id: str):
        """å¤„ç†æ™ºèƒ½ä½“æ¶ˆæ¯"""
        queue_key = f"queue:{agent_id}"
        
        while True:
            # ä»é˜Ÿåˆ—ä¸­è·å–æ¶ˆæ¯
            message_data = await self.redis.rpop(queue_key)
            
            if not message_data:
                break
            
            try:
                # ååºåˆ—åŒ–æ¶ˆæ¯
                message_dict = json.loads(message_data)
                message_dict['timestamp'] = datetime.fromisoformat(message_dict['timestamp'])
                message = Message(**message_dict)
                
                # è°ƒç”¨å¤„ç†å™¨
                if agent_id in self.subscribers:
                    for handler in self.subscribers[agent_id]:
                        try:
                            await handler(message)
                        except Exception as e:
                            print(f"æ¶ˆæ¯å¤„ç†é”™è¯¯: {e}")
                
            except Exception as e:
                print(f"æ¶ˆæ¯ååºåˆ—åŒ–é”™è¯¯: {e}")
    
    async def _message_processing_loop(self):
        """æ¶ˆæ¯å¤„ç†ä¸»å¾ªç¯"""
        while self.is_running:
            try:
                # æ¸…ç†è¿‡æœŸæ¶ˆæ¯
                await self._cleanup_expired_messages()
                
                # å¤„ç†ä¼˜å…ˆçº§æ¶ˆæ¯
                await self._process_priority_messages()
                
                await asyncio.sleep(1)
                
            except Exception as e:
                print(f"æ¶ˆæ¯å¤„ç†å¾ªç¯é”™è¯¯: {e}")
                await asyncio.sleep(5)
    
    async def _cleanup_expired_messages(self):
        """æ¸…ç†è¿‡æœŸæ¶ˆæ¯"""
        # è·å–æ‰€æœ‰é˜Ÿåˆ—
        queue_keys = await self.redis.keys("queue:*")
        
        for queue_key in queue_keys:
            # æ£€æŸ¥é˜Ÿåˆ—TTL
            ttl = await self.redis.ttl(queue_key)
            if ttl == -1:  # æ²¡æœ‰è®¾ç½®TTL
                await self.redis.expire(queue_key, 3600)  # è®¾ç½®é»˜è®¤TTL
    
    async def _process_priority_messages(self):
        """å¤„ç†ä¼˜å…ˆçº§æ¶ˆæ¯"""
        # å®ç°ä¼˜å…ˆçº§æ¶ˆæ¯å¤„ç†é€»è¾‘
        pass
    
    async def get_queue_stats(self, agent_id: str) -> Dict[str, Any]:
        """è·å–é˜Ÿåˆ—ç»Ÿè®¡ä¿¡æ¯"""
        queue_key = f"queue:{agent_id}"
        
        queue_length = await self.redis.llen(queue_key)
        ttl = await self.redis.ttl(queue_key)
        
        return {
            "agent_id": agent_id,
            "queue_length": queue_length,
            "ttl": ttl
        }
```

### 2.3 å·¥ä½œæµå¼•æ“

#### 2.3.1 ä¼ä¸šçº§å·¥ä½œæµå¼•æ“

```python
from enum import Enum
from typing import Dict, List, Any, Optional, Callable
import asyncio
import uuid
from datetime import datetime

class WorkflowStatus(Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

class TaskStatus(Enum):
    WAITING = "waiting"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"

@dataclass
class WorkflowTask:
    task_id: str
    name: str
    agent_type: str
    required_capabilities: List[str]
    inputs: Dict[str, Any]
    outputs: Dict[str, Any] = None
    status: TaskStatus = TaskStatus.WAITING
    dependencies: List[str] = None
    retry_count: int = 0
    max_retries: int = 3
    timeout: int = 300  # 5åˆ†é’Ÿè¶…æ—¶
    created_at: datetime = None
    started_at: datetime = None
    completed_at: datetime = None
    error_message: str = None

@dataclass
class Workflow:
    workflow_id: str
    name: str
    description: str
    tasks: List[WorkflowTask]
    status: WorkflowStatus = WorkflowStatus.PENDING
    created_at: datetime = None
    started_at: datetime = None
    completed_at: datetime = None
    context: Dict[str, Any] = None

class WorkflowEngine:
    """ä¼ä¸šçº§å·¥ä½œæµå¼•æ“"""
    
    def __init__(self, agent_manager: AgentManager, message_bus: MessageBus):
        self.agent_manager = agent_manager
        self.message_bus = message_bus
        self.workflows: Dict[str, Workflow] = {}
        self.running_tasks: Dict[str, asyncio.Task] = {}
        self.task_callbacks: Dict[str, Callable] = {}
    
    async def create_workflow(self, name: str, description: str, 
                            tasks: List[Dict[str, Any]]) -> str:
        """åˆ›å»ºå·¥ä½œæµ"""
        workflow_id = str(uuid.uuid4())
        
        # åˆ›å»ºä»»åŠ¡å¯¹è±¡
        workflow_tasks = []
        for task_data in tasks:
            task = WorkflowTask(
                task_id=str(uuid.uuid4()),
                name=task_data["name"],
                agent_type=task_data["agent_type"],
                required_capabilities=task_data.get("required_capabilities", []),
                inputs=task_data.get("inputs", {}),
                dependencies=task_data.get("dependencies", []),
                max_retries=task_data.get("max_retries", 3),
                timeout=task_data.get("timeout", 300),
                created_at=datetime.utcnow()
            )
            workflow_tasks.append(task)
        
        # åˆ›å»ºå·¥ä½œæµ
        workflow = Workflow(
            workflow_id=workflow_id,
            name=name,
            description=description,
            tasks=workflow_tasks,
            created_at=datetime.utcnow(),
            context={}
        )
        
        self.workflows[workflow_id] = workflow
        return workflow_id
    
    async def start_workflow(self, workflow_id: str) -> bool:
        """å¯åŠ¨å·¥ä½œæµ"""
        if workflow_id not in self.workflows:
            return False
        
        workflow = self.workflows[workflow_id]
        workflow.status = WorkflowStatus.RUNNING
        workflow.started_at = datetime.utcnow()
        
        # å¯åŠ¨å·¥ä½œæµæ‰§è¡Œ
        asyncio.create_task(self._execute_workflow(workflow))
        
        return True
    
    async def _execute_workflow(self, workflow: Workflow):
        """æ‰§è¡Œå·¥ä½œæµ"""
        try:
            while True:
                # æŸ¥æ‰¾å¯æ‰§è¡Œçš„ä»»åŠ¡
                ready_tasks = self._get_ready_tasks(workflow)
                
                if not ready_tasks:
                    # æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ä»»åŠ¡éƒ½å®Œæˆ
                    if self._is_workflow_completed(workflow):
                        workflow.status = WorkflowStatus.COMPLETED
                        workflow.completed_at = datetime.utcnow()
                        break
                    else:
                        # ç­‰å¾…æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡
                        await asyncio.sleep(1)
                        continue
                
                # å¹¶è¡Œæ‰§è¡Œå‡†å¤‡å¥½çš„ä»»åŠ¡
                for task in ready_tasks:
                    asyncio.create_task(self._execute_task(workflow, task))
                
                await asyncio.sleep(0.1)  # çŸ­æš‚ç­‰å¾…
                
        except Exception as e:
            workflow.status = WorkflowStatus.FAILED
            print(f"å·¥ä½œæµæ‰§è¡Œå¤±è´¥ {workflow.workflow_id}: {e}")
    
    def _get_ready_tasks(self, workflow: Workflow) -> List[WorkflowTask]:
        """è·å–å‡†å¤‡æ‰§è¡Œçš„ä»»åŠ¡"""
        ready_tasks = []
        
        for task in workflow.tasks:
            if task.status != TaskStatus.WAITING:
                continue
            
            # æ£€æŸ¥ä¾èµ–æ˜¯å¦æ»¡è¶³
            if self._are_dependencies_satisfied(workflow, task):
                ready_tasks.append(task)
        
        return ready_tasks
    
    def _are_dependencies_satisfied(self, workflow: Workflow, task: WorkflowTask) -> bool:
        """æ£€æŸ¥ä»»åŠ¡ä¾èµ–æ˜¯å¦æ»¡è¶³"""
        if not task.dependencies:
            return True
        
        task_dict = {t.task_id: t for t in workflow.tasks}
        
        for dep_id in task.dependencies:
            if dep_id not in task_dict:
                return False
            
            dep_task = task_dict[dep_id]
            if dep_task.status != TaskStatus.COMPLETED:
                return False
        
        return True
    
    async def _execute_task(self, workflow: Workflow, task: WorkflowTask):
        """æ‰§è¡Œå•ä¸ªä»»åŠ¡"""
        task.status = TaskStatus.RUNNING
        task.started_at = datetime.utcnow()
        
        try:
            # åˆ†é…æ™ºèƒ½ä½“
            agent_id = await self.agent_manager.assign_task(
                {"task": task.inputs, "task_id": task.task_id},
                task.required_capabilities
            )
            
            if not agent_id:
                raise Exception("æ²¡æœ‰å¯ç”¨çš„æ™ºèƒ½ä½“")
            
            # æ‰§è¡Œä»»åŠ¡ï¼ˆå¸¦è¶…æ—¶ï¼‰
            result = await asyncio.wait_for(
                self._run_task_on_agent(agent_id, task),
                timeout=task.timeout
            )
            
            # ä»»åŠ¡æˆåŠŸå®Œæˆ
            task.outputs = result
            task.status = TaskStatus.COMPLETED
            task.completed_at = datetime.utcnow()
            
            # æ›´æ–°å·¥ä½œæµä¸Šä¸‹æ–‡
            workflow.context[task.task_id] = result
            
            # é€šçŸ¥æ™ºèƒ½ä½“ç®¡ç†å™¨ä»»åŠ¡å®Œæˆ
            await self.agent_manager.complete_task(agent_id, success=True)
            
        except asyncio.TimeoutError:
            task.error_message = "ä»»åŠ¡æ‰§è¡Œè¶…æ—¶"
            await self._handle_task_failure(workflow, task)
            
        except Exception as e:
            task.error_message = str(e)
            await self._handle_task_failure(workflow, task)
    
    async def _run_task_on_agent(self, agent_id: str, task: WorkflowTask) -> Dict[str, Any]:
        """åœ¨æ™ºèƒ½ä½“ä¸Šè¿è¡Œä»»åŠ¡"""
        # è·å–æ™ºèƒ½ä½“å®ä¾‹
        agent_instance = self.agent_manager.agent_instances.get(agent_id)
        
        if not agent_instance:
            raise Exception(f"æ™ºèƒ½ä½“å®ä¾‹ä¸å­˜åœ¨: {agent_id}")
        
        # æ‰§è¡Œä»»åŠ¡
        if hasattr(agent_instance, 'process_task'):
            return await agent_instance.process_task(task.inputs)
        else:
            raise Exception("æ™ºèƒ½ä½“ä¸æ”¯æŒä»»åŠ¡å¤„ç†")
    
    async def _handle_task_failure(self, workflow: Workflow, task: WorkflowTask):
        """å¤„ç†ä»»åŠ¡å¤±è´¥"""
        task.retry_count += 1
        
        if task.retry_count <= task.max_retries:
            # é‡è¯•ä»»åŠ¡
            task.status = TaskStatus.WAITING
            print(f"ä»»åŠ¡é‡è¯• {task.task_id} (ç¬¬{task.retry_count}æ¬¡)")
        else:
            # ä»»åŠ¡æœ€ç»ˆå¤±è´¥
            task.status = TaskStatus.FAILED
            workflow.status = WorkflowStatus.FAILED
            print(f"ä»»åŠ¡æœ€ç»ˆå¤±è´¥ {task.task_id}: {task.error_message}")
    
    def _is_workflow_completed(self, workflow: Workflow) -> bool:
        """æ£€æŸ¥å·¥ä½œæµæ˜¯å¦å®Œæˆ"""
        for task in workflow.tasks:
            if task.status in [TaskStatus.WAITING, TaskStatus.RUNNING]:
                return False
        return True
    
    def get_workflow_status(self, workflow_id: str) -> Optional[Dict[str, Any]]:
        """è·å–å·¥ä½œæµçŠ¶æ€"""
        if workflow_id not in self.workflows:
            return None
        
        workflow = self.workflows[workflow_id]
        
        task_stats = {}
        for status in TaskStatus:
            task_stats[status.value] = sum(
                1 for task in workflow.tasks if task.status == status
            )
        
        return {
            "workflow_id": workflow_id,
            "name": workflow.name,
            "status": workflow.status.value,
            "created_at": workflow.created_at.isoformat() if workflow.created_at else None,
            "started_at": workflow.started_at.isoformat() if workflow.started_at else None,
            "completed_at": workflow.completed_at.isoformat() if workflow.completed_at else None,
            "total_tasks": len(workflow.tasks),
            "task_statistics": task_stats
        }
```

---

## 3. å®‰å…¨æ¶æ„è®¾è®¡

### 3.1 è®¤è¯ä¸æˆæƒ

#### 3.1.1 JWTè®¤è¯ç³»ç»Ÿ

```python
import jwt
import bcrypt
from datetime import datetime, timedelta
from typing import Dict, Optional, List
from fastapi import HTTPException, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

class AuthenticationService:
    """è®¤è¯æœåŠ¡"""
    
    def __init__(self, secret_key: str, algorithm: str = "HS256"):
        self.secret_key = secret_key
        self.algorithm = algorithm
        self.token_expiry = timedelta(hours=24)
        self.refresh_token_expiry = timedelta(days=7)
    
    def hash_password(self, password: str) -> str:
        """å¯†ç å“ˆå¸Œ"""
        salt = bcrypt.gensalt()
        return bcrypt.hashpw(password.encode('utf-8'), salt).decode('utf-8')
    
    def verify_password(self, password: str, hashed_password: str) -> bool:
        """éªŒè¯å¯†ç """
        return bcrypt.checkpw(password.encode('utf-8'), hashed_password.encode('utf-8'))
    
    def create_access_token(self, user_id: str, roles: List[str]) -> str:
        """åˆ›å»ºè®¿é—®ä»¤ç‰Œ"""
        payload = {
            "user_id": user_id,
            "roles": roles,
            "exp": datetime.utcnow() + self.token_expiry,
            "iat": datetime.utcnow(),
            "type": "access"
        }
        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
    
    def create_refresh_token(self, user_id: str) -> str:
        """åˆ›å»ºåˆ·æ–°ä»¤ç‰Œ"""
        payload = {
            "user_id": user_id,
            "exp": datetime.utcnow() + self.refresh_token_expiry,
            "iat": datetime.utcnow(),
            "type": "refresh"
        }
        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
    
    def verify_token(self, token: str) -> Dict[str, any]:
        """éªŒè¯ä»¤ç‰Œ"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            return payload
        except jwt.ExpiredSignatureError:
            raise HTTPException(status_code=401, detail="ä»¤ç‰Œå·²è¿‡æœŸ")
        except jwt.InvalidTokenError:
            raise HTTPException(status_code=401, detail="æ— æ•ˆä»¤ç‰Œ")

class AuthorizationService:
    """æˆæƒæœåŠ¡"""
    
    def __init__(self):
        self.permissions = {
            "admin": ["*"],  # ç®¡ç†å‘˜æ‹¥æœ‰æ‰€æœ‰æƒé™
            "agent_manager": ["agent:create", "agent:read", "agent:update", "agent:delete"],
            "workflow_manager": ["workflow:create", "workflow:read", "workflow:update", "workflow:delete"],
            "monitor": ["system:read", "metrics:read"],
            "user": ["agent:read", "workflow:read"]
        }
    
    def check_permission(self, user_roles: List[str], required_permission: str) -> bool:
        """æ£€æŸ¥æƒé™"""
        for role in user_roles:
            role_permissions = self.permissions.get(role, [])
            
            # æ£€æŸ¥æ˜¯å¦æœ‰é€šé…ç¬¦æƒé™
            if "*" in role_permissions:
                return True
            
            # æ£€æŸ¥å…·ä½“æƒé™
            if required_permission in role_permissions:
                return True
            
            # æ£€æŸ¥æ¨¡å¼åŒ¹é…æƒé™
            for permission in role_permissions:
                if self._match_permission(permission, required_permission):
                    return True
        
        return False
    
    def _match_permission(self, pattern: str, permission: str) -> bool:
        """æƒé™æ¨¡å¼åŒ¹é…"""
        if pattern.endswith("*"):
            prefix = pattern[:-1]
            return permission.startswith(prefix)
        return pattern == permission

# FastAPIä¾èµ–æ³¨å…¥
security = HTTPBearer()
auth_service = AuthenticationService("your-secret-key")
authz_service = AuthorizationService()

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """è·å–å½“å‰ç”¨æˆ·"""
    token = credentials.credentials
    payload = auth_service.verify_token(token)
    return payload

def require_permission(permission: str):
    """æƒé™è£…é¥°å™¨"""
    def decorator(func):
        async def wrapper(*args, **kwargs):
            # ä»ä¾èµ–æ³¨å…¥ä¸­è·å–ç”¨æˆ·ä¿¡æ¯
            user = kwargs.get('current_user')
            if not user:
                raise HTTPException(status_code=401, detail="æœªè®¤è¯")
            
            user_roles = user.get('roles', [])
            if not authz_service.check_permission(user_roles, permission):
                raise HTTPException(status_code=403, detail="æƒé™ä¸è¶³")
            
            return await func(*args, **kwargs)
        return wrapper
    return decorator
```

### 3.2 æ•°æ®åŠ å¯†ä¸å®‰å…¨

#### 3.2.1 æ•°æ®åŠ å¯†æœåŠ¡

```python
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
import os
from typing import Union

class EncryptionService:
    """æ•°æ®åŠ å¯†æœåŠ¡"""
    
    def __init__(self, password: str = None):
        if password:
            self.key = self._derive_key(password)
        else:
            self.key = Fernet.generate_key()
        
        self.cipher = Fernet(self.key)
    
    def _derive_key(self, password: str) -> bytes:
        """ä»å¯†ç æ´¾ç”Ÿå¯†é’¥"""
        password_bytes = password.encode()
        salt = b'salt_'  # åœ¨ç”Ÿäº§ç¯å¢ƒä¸­åº”ä½¿ç”¨éšæœºç›
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(password_bytes))
        return key
    
    def encrypt(self, data: Union[str, bytes]) -> str:
        """åŠ å¯†æ•°æ®"""
        if isinstance(data, str):
            data = data.encode()
        
        encrypted_data = self.cipher.encrypt(data)
        return base64.urlsafe_b64encode(encrypted_data).decode()
    
    def decrypt(self, encrypted_data: str) -> str:
        """è§£å¯†æ•°æ®"""
        encrypted_bytes = base64.urlsafe_b64decode(encrypted_data.encode())
        decrypted_data = self.cipher.decrypt(encrypted_bytes)
        return decrypted_data.decode()
    
    def encrypt_dict(self, data: Dict[str, Any]) -> Dict[str, str]:
        """åŠ å¯†å­—å…¸æ•°æ®"""
        encrypted_dict = {}
        for key, value in data.items():
            encrypted_dict[key] = self.encrypt(str(value))
        return encrypted_dict
    
    def decrypt_dict(self, encrypted_dict: Dict[str, str]) -> Dict[str, str]:
        """è§£å¯†å­—å…¸æ•°æ®"""
        decrypted_dict = {}
        for key, encrypted_value in encrypted_dict.items():
            decrypted_dict[key] = self.decrypt(encrypted_value)
        return decrypted_dict

class SecureDataStore:
    """å®‰å…¨æ•°æ®å­˜å‚¨"""
    
    def __init__(self, encryption_service: EncryptionService):
        self.encryption = encryption_service
        self.data_store = {}  # åœ¨å®é™…åº”ç”¨ä¸­åº”ä½¿ç”¨æ•°æ®åº“
    
    async def store_sensitive_data(self, key: str, data: Dict[str, Any]) -> bool:
        """å­˜å‚¨æ•æ„Ÿæ•°æ®"""
        try:
            # åŠ å¯†æ•°æ®
            encrypted_data = self.encryption.encrypt_dict(data)
            
            # å­˜å‚¨åŠ å¯†åçš„æ•°æ®
            self.data_store[key] = {
                "data": encrypted_data,
                "created_at": datetime.utcnow().isoformat(),
                "encrypted": True
            }
            
            return True
        except Exception as e:
            print(f"æ•°æ®å­˜å‚¨å¤±è´¥: {e}")
            return False
    
    async def retrieve_sensitive_data(self, key: str) -> Optional[Dict[str, Any]]:
        """æ£€ç´¢æ•æ„Ÿæ•°æ®"""
        try:
            if key not in self.data_store:
                return None
            
            stored_data = self.data_store[key]
            
            if stored_data.get("encrypted", False):
                # è§£å¯†æ•°æ®
                decrypted_data = self.encryption.decrypt_dict(stored_data["data"])
                return decrypted_data
            else:
                return stored_data["data"]
                
        except Exception as e:
            print(f"æ•°æ®æ£€ç´¢å¤±è´¥: {e}")
            return None
```

---

## 4. ç³»ç»Ÿå®ç°

### 4.1 å®Œæ•´ç³»ç»Ÿé›†æˆ

#### 4.1.1 ä¼ä¸šçº§å¤šæ™ºèƒ½ä½“ç³»ç»Ÿ

```python
from fastapi import FastAPI, Depends, HTTPException
from pydantic import BaseModel
import asyncio
from typing import Dict, List, Any, Optional

class EnterpriseMultiAgentSystem:
    """ä¼ä¸šçº§å¤šæ™ºèƒ½ä½“ç³»ç»Ÿ"""
    
    def __init__(self):
        self.app = FastAPI(title="Enterprise Multi-Agent System")
        self.agent_manager = AgentManager()
        self.message_bus = MessageBus()
        self.workflow_engine = WorkflowEngine(self.agent_manager, self.message_bus)
        self.auth_service = AuthenticationService("your-secret-key")
        self.authz_service = AuthorizationService()
        self.encryption_service = EncryptionService()
        self.secure_store = SecureDataStore(self.encryption_service)
        
        self._setup_routes()
    
    def _setup_routes(self):
        """è®¾ç½®APIè·¯ç”±"""
        
        @self.app.post("/auth/login")
        async def login(credentials: LoginRequest):
            # éªŒè¯ç”¨æˆ·å‡­æ®ï¼ˆç®€åŒ–å®ç°ï¼‰
            if credentials.username == "admin" and credentials.password == "password":
                access_token = self.auth_service.create_access_token(
                    user_id="admin",
                    roles=["admin"]
                )
                refresh_token = self.auth_service.create_refresh_token("admin")
                
                return {
                    "access_token": access_token,
                    "refresh_token": refresh_token,
                    "token_type": "bearer"
                }
            else:
                raise HTTPException(status_code=401, detail="æ— æ•ˆå‡­æ®")
        
        @self.app.post("/agents/register")
        async def register_agent(
            request: AgentRegistrationRequest,
            current_user: Dict = Depends(get_current_user)
        ):
            # æ£€æŸ¥æƒé™
            if not self.authz_service.check_permission(
                current_user.get("roles", []), 
                "agent:create"
            ):
                raise HTTPException(status_code=403, detail="æƒé™ä¸è¶³")
            
            # æ³¨å†Œæ™ºèƒ½ä½“
            agent_id = await self.agent_manager.register_agent(
                request.agent_type,
                request.capabilities,
                request.agent_factory
            )
            
            return {"agent_id": agent_id, "status": "registered"}
        
        @self.app.post("/workflows/create")
        async def create_workflow(
            request: WorkflowCreateRequest,
            current_user: Dict = Depends(get_current_user)
        ):
            # æ£€æŸ¥æƒé™
            if not self.authz_service.check_permission(
                current_user.get("roles", []), 
                "workflow:create"
            ):
                raise HTTPException(status_code=403, detail="æƒé™ä¸è¶³")
            
            # åˆ›å»ºå·¥ä½œæµ
            workflow_id = await self.workflow_engine.create_workflow(
                request.name,
                request.description,
                request.tasks
            )
            
            return {"workflow_id": workflow_id, "status": "created"}
        
        @self.app.post("/workflows/{workflow_id}/start")
        async def start_workflow(
            workflow_id: str,
            current_user: Dict = Depends(get_current_user)
        ):
            # æ£€æŸ¥æƒé™
            if not self.authz_service.check_permission(
                current_user.get("roles", []), 
                "workflow:update"
            ):
                raise HTTPException(status_code=403, detail="æƒé™ä¸è¶³")
            
            # å¯åŠ¨å·¥ä½œæµ
            success = await self.workflow_engine.start_workflow(workflow_id)
            
            if success:
                return {"status": "started"}
            else:
                raise HTTPException(status_code=404, detail="å·¥ä½œæµä¸å­˜åœ¨")
        
        @self.app.get("/system/status")
        async def get_system_status(
            current_user: Dict = Depends(get_current_user)
        ):
            # æ£€æŸ¥æƒé™
            if not self.authz_service.check_permission(
                current_user.get("roles", []), 
                "system:read"
            ):
                raise HTTPException(status_code=403, detail="æƒé™ä¸è¶³")
            
            # è·å–ç³»ç»ŸçŠ¶æ€
            agent_stats = self.agent_manager.get_agent_statistics()
            
            return {
                "system_status": "healthy",
                "agent_statistics": agent_stats,
                "timestamp": datetime.utcnow().isoformat()
            }
    
    async def initialize(self):
        """åˆå§‹åŒ–ç³»ç»Ÿ"""
        await self.message_bus.initialize()
        print("ä¼ä¸šçº§å¤šæ™ºèƒ½ä½“ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ")
    
    async def shutdown(self):
        """å…³é—­ç³»ç»Ÿ"""
        self.message_bus.is_running = False
        print("ä¼ä¸šçº§å¤šæ™ºèƒ½ä½“ç³»ç»Ÿå·²å…³é—­")

# è¯·æ±‚æ¨¡å‹
class LoginRequest(BaseModel):
    username: str
    password: str

class AgentRegistrationRequest(BaseModel):
    agent_type: str
    capabilities: List[str]
    agent_factory: Any  # åœ¨å®é™…åº”ç”¨ä¸­éœ€è¦æ›´å…·ä½“çš„ç±»å‹

class WorkflowCreateRequest(BaseModel):
    name: str
    description: str
    tasks: List[Dict[str, Any]]
```

---

## 5. éƒ¨ç½²ä¸è¿ç»´

### 5.1 Dockerå®¹å™¨åŒ–éƒ¨ç½²

#### 5.1.1 Dockerfile

```dockerfile
FROM python:3.9-slim

WORKDIR /app

# å®‰è£…ç³»ç»Ÿä¾èµ–
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY requirements.txt .

# å®‰è£…Pythonä¾èµ–
RUN pip install --no-cache-dir -r requirements.txt

# å¤åˆ¶åº”ç”¨ä»£ç 
COPY . .

# æš´éœ²ç«¯å£
EXPOSE 8000

# å¯åŠ¨å‘½ä»¤
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

#### 5.1.2 Docker Composeé…ç½®

```yaml
version: '3.8'

services:
  multi-agent-system:
    build: .
    ports:
      - "8000:8000"
    environment:
      - REDIS_URL=redis://redis:6379
      - DATABASE_URL=postgresql://user:password@postgres:5432/multiagent
    depends_on:
      - redis
      - postgres
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=multiagent
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - multi-agent-system
    restart: unless-stopped

volumes:
  redis_data:
  postgres_data:
```

### 5.2 ç›‘æ§ä¸æ—¥å¿—

#### 5.2.1 ç³»ç»Ÿç›‘æ§é…ç½®

```python
import logging
import sys
from datetime import datetime
from typing import Dict, Any
import psutil
import asyncio

class SystemMonitor:
    """ç³»ç»Ÿç›‘æ§"""
    
    def __init__(self):
        self.setup_logging()
        self.metrics = {}
        self.is_monitoring = False
    
    def setup_logging(self):
        """è®¾ç½®æ—¥å¿—"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('/app/logs/system.log'),
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    async def start_monitoring(self, interval: int = 60):
        """å¼€å§‹ç›‘æ§"""
        self.is_monitoring = True
        self.logger.info("ç³»ç»Ÿç›‘æ§å·²å¯åŠ¨")
        
        while self.is_monitoring:
            try:
                await self.collect_system_metrics()
                await self.check_system_health()
                await asyncio.sleep(interval)
            except Exception as e:
                self.logger.error(f"ç›‘æ§é”™è¯¯: {e}")
                await asyncio.sleep(interval)
    
    async def collect_system_metrics(self):
        """æ”¶é›†ç³»ç»ŸæŒ‡æ ‡"""
        # CPUä½¿ç”¨ç‡
        cpu_percent = psutil.cpu_percent(interval=1)
        
        # å†…å­˜ä½¿ç”¨æƒ…å†µ
        memory = psutil.virtual_memory()
        
        # ç£ç›˜ä½¿ç”¨æƒ…å†µ
        disk = psutil.disk_usage('/')
        
        # ç½‘ç»œç»Ÿè®¡
        network = psutil.net_io_counters()
        
        self.metrics = {
            "timestamp": datetime.utcnow().isoformat(),
            "cpu_percent": cpu_percent,
            "memory": {
                "total": memory.total,
                "available": memory.available,
                "percent": memory.percent,
                "used": memory.used
            },
            "disk": {
                "total": disk.total,
                "used": disk.used,
                "free": disk.free,
                "percent": (disk.used / disk.total) * 100
            },
            "network": {
                "bytes_sent": network.bytes_sent,
                "bytes_recv": network.bytes_recv,
                "packets_sent": network.packets_sent,
                "packets_recv": network.packets_recv
            }
        }
        
        self.logger.info(f"ç³»ç»ŸæŒ‡æ ‡: CPU {cpu_percent}%, å†…å­˜ {memory.percent}%, ç£ç›˜ {self.metrics['disk']['percent']:.1f}%")
    
    async def check_system_health(self):
        """æ£€æŸ¥ç³»ç»Ÿå¥åº·çŠ¶æ€"""
        alerts = []
        
        # CPUå‘Šè­¦
        if self.metrics["cpu_percent"] > 80:
            alerts.append(f"CPUä½¿ç”¨ç‡è¿‡é«˜: {self.metrics['cpu_percent']}%")
        
        # å†…å­˜å‘Šè­¦
        if self.metrics["memory"]["percent"] > 85:
            alerts.append(f"å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜: {self.metrics['memory']['percent']}%")
        
        # ç£ç›˜å‘Šè­¦
        if self.metrics["disk"]["percent"] > 90:
            alerts.append(f"ç£ç›˜ä½¿ç”¨ç‡è¿‡é«˜: {self.metrics['disk']['percent']:.1f}%")
        
        # å‘é€å‘Šè­¦
        for alert in alerts:
            self.logger.warning(f"ç³»ç»Ÿå‘Šè­¦: {alert}")
            await self.send_alert(alert)
    
    async def send_alert(self, message: str):
        """å‘é€å‘Šè­¦"""
        # è¿™é‡Œå¯ä»¥é›†æˆé‚®ä»¶ã€Slackã€é’‰é’‰ç­‰å‘Šè­¦æ¸ é“
        print(f"[ALERT] {message}")
    
    def get_current_metrics(self) -> Dict[str, Any]:
        """è·å–å½“å‰æŒ‡æ ‡"""
        return self.metrics
```

---

## 6. å®è·µé¡¹ç›®

### é¡¹ç›®ï¼šæ„å»ºä¼ä¸šçº§å®¢æœæ™ºèƒ½ä½“ç³»ç»Ÿ

#### 6.1.1 é¡¹ç›®éœ€æ±‚

1. **å¤šæ™ºèƒ½ä½“åä½œ**ï¼šæ„å›¾è¯†åˆ«ã€çŸ¥è¯†æ£€ç´¢ã€å›ç­”ç”Ÿæˆ
2. **å·¥ä½œæµç®¡ç†**ï¼šå®¢æœæµç¨‹è‡ªåŠ¨åŒ–
3. **ç›‘æ§å‘Šè­¦**ï¼šç³»ç»Ÿæ€§èƒ½å’ŒæœåŠ¡è´¨é‡ç›‘æ§
4. **å®‰å…¨è®¤è¯**ï¼šç”¨æˆ·è®¤è¯å’Œæƒé™ç®¡ç†

#### 6.1.2 å®ç°æ¡†æ¶

```python
# å­¦å‘˜éœ€è¦å®Œæˆçš„é¡¹ç›®ä»£ç æ¡†æ¶
class CustomerServiceSystem(EnterpriseMultiAgentSystem):
    def __init__(self):
        super().__init__()
        self.setup_customer_service_agents()
        self.setup_customer_service_workflows()
    
    def setup_customer_service_agents(self):
        """è®¾ç½®å®¢æœæ™ºèƒ½ä½“"""
        # TODO: å®ç°æ„å›¾è¯†åˆ«æ™ºèƒ½ä½“
        # TODO: å®ç°çŸ¥è¯†æ£€ç´¢æ™ºèƒ½ä½“
        # TODO: å®ç°å›ç­”ç”Ÿæˆæ™ºèƒ½ä½“
        pass
    
    def setup_customer_service_workflows(self):
        """è®¾ç½®å®¢æœå·¥ä½œæµ"""
        # TODO: å®šä¹‰å®¢æœå¤„ç†æµç¨‹
        # TODO: é…ç½®å¼‚å¸¸å¤„ç†æœºåˆ¶
        pass
    
    async def handle_customer_query(self, query: str, customer_id: str):
        """å¤„ç†å®¢æˆ·æŸ¥è¯¢"""
        # TODO: åˆ›å»ºå¹¶æ‰§è¡Œå®¢æœå·¥ä½œæµ
        pass
```

## æ€»ç»“

æœ¬è¯¾ç¨‹æ¶µç›–äº†ä¼ä¸šçº§å¤šæ™ºèƒ½ä½“ç³»ç»Ÿçš„å®Œæ•´æ¶æ„è®¾è®¡å’Œå®ç°ï¼ŒåŒ…æ‹¬ï¼š

1. **æ¶æ„è®¾è®¡**ï¼šåˆ†å±‚æ¶æ„ã€å¾®æœåŠ¡æ¨¡å¼ã€è®¾è®¡åŸåˆ™
2. **æ ¸å¿ƒç»„ä»¶**ï¼šæ™ºèƒ½ä½“ç®¡ç†ã€æ¶ˆæ¯æ€»çº¿ã€å·¥ä½œæµå¼•æ“
3. **å®‰å…¨æœºåˆ¶**ï¼šè®¤è¯æˆæƒã€æ•°æ®åŠ å¯†ã€å®‰å…¨å­˜å‚¨
4. **ç³»ç»Ÿå®ç°**ï¼šå®Œæ•´çš„ä¼ä¸šçº§ç³»ç»Ÿé›†æˆ
5. **éƒ¨ç½²è¿ç»´**ï¼šå®¹å™¨åŒ–éƒ¨ç½²ã€ç›‘æ§å‘Šè­¦ã€æ—¥å¿—ç®¡ç†

ä¸‹ä¸€è¯¾ç¨‹å°†å­¦ä¹ åº”ç”¨å®è·µä¸éƒ¨ç½²è¿ç»´çš„é«˜çº§æŠ€æœ¯ã€‚
